<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale-1.0">
    <title>动态雷达图生成器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #f0f4f8;
            color: #1e293b;
        }
        .container {
            background-color: white;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            padding: 1.25rem; /* Reduced padding */
            width: 90%;
            max-width: 896px; /* Increased for 2-col layout */
        }
        canvas {
            width: 100%;
            height: auto;
            aspect-ratio: 1 / 1;
        }
        .form-input {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            border: 1px solid #cbd5e1;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .form-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4);
        }
        .color-picker-wrapper {
            position: relative;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            overflow: hidden;
            border: 2px solid #e2e8f0;
        }
        input[type="color"] {
            position: absolute;
            top: -10px;
            left: -10px;
            width: 60px;
            height: 60px;
            border: none;
            cursor: pointer;
            padding: 0;
            background: none;
        }
    </style>
</head>
<body class="bg-gray-100">

    <div class="container">
        <div class="text-center">
            <h1 class="text-xl font-bold mb-2 text-slate-800">自定义属性雷达图</h1>
            <p class="text-slate-500 mb-4">输入属性和数值，调整外观，然后生成您的专属图表。</p>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-x-8 items-start mt-4">
            <!-- Left Column: Chart -->
            <div>
                <canvas id="radarChart" class="mx-auto"></canvas>
            </div>

            <!-- Right Column: Controls -->
            <div>
                <div class="space-y-3">
                    <h3 class="text-base font-semibold text-slate-700">属性设置</h3>
                    <!-- Attribute Inputs -->
                    <div class="grid grid-cols-[1fr,auto] gap-4 items-center" id="attr-0">
                        <input type="text" value="属性 a" class="form-input" placeholder="属性名">
                        <input type="number" value="3" min="0" max="5" step="0.1" class="form-input w-20" placeholder="数值">
                    </div>
                    <div class="grid grid-cols-[1fr,auto] gap-4 items-center" id="attr-1">
                        <input type="text" value="属性 b" class="form-input" placeholder="属性名">
                        <input type="number" value="4" min="0" max="5" step="0.1" class="form-input w-20" placeholder="数值">
                    </div>
                    <div class="grid grid-cols-[1fr,auto] gap-4 items-center" id="attr-2">
                        <input type="text" value="属性 c" class="form-input" placeholder="属性名">
                        <input type="number" value="3" min="0" max="5" step="0.1" class="form-input w-20" placeholder="数值">
                    </div>
                    <div class="grid grid-cols-[1fr,auto] gap-4 items-center" id="attr-3">
                        <input type="text" value="属性 d" class="form-input" placeholder="属性名">
                        <input type="number" value="4" min="0" max="5" step="0.1" class="form-input w-20" placeholder="数值">
                    </div>
                    <div class="grid grid-cols-[1fr,auto] gap-4 items-center" id="attr-4">
                        <input type="text" value="属性 e" class="form-input" placeholder="属性名">
                        <input type="number" value="2" min="0" max="5" step="0.1" class="form-input w-20" placeholder="数值">
                    </div>
                    <div class="grid grid-cols-[1fr,auto] gap-4 items-center" id="attr-5">
                        <input type="text" value="属性 f" class="form-input" placeholder="属性名">
                        <input type="number" value="5" min="0" max="5" step="0.1" class="form-input w-20" placeholder="数值">
                    </div>
                </div>

                <div class="mt-6 space-y-3">
                    <h3 class="text-base font-semibold text-slate-700">图表自定义</h3>
                    <!-- Customization Inputs -->
                    <div class="flex items-center justify-between">
                        <label for="speedControl" class="text-sm font-medium text-slate-600">动画速度</label>
                        <input id="speedControl" type="range" min="500" max="3000" value="1200" class="w-1/2">
                    </div>
                     <div class="flex items-center justify-between">
                        <label for="colorControl" class="text-sm font-medium text-slate-600">线条颜色</label>
                        <div class="color-picker-wrapper">
                            <input id="colorControl" type="color" value="#2563eb">
                        </div>
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="labelDistanceControl" class="text-sm font-medium text-slate-600">标签距离</label>
                        <input id="labelDistanceControl" type="range" min="105" max="140" value="120" class="w-1/2">
                    </div>
                </div>

                <button id="generateBtn" class="mt-6 w-full bg-blue-600 text-white font-semibold py-2.5 px-6 rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 transition-transform transform hover:scale-105">
                    生成图表
                </button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('radarChart');
            const ctx = canvas.getContext('2d');
            const generateBtn = document.getElementById('generateBtn');

            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            const centerX = canvas.width / (2 * dpr);
            const centerY = canvas.height / (2 * dpr);
            const maxRadius = Math.min(centerX, centerY) * 0.75; // Adjusted for better fit
            const numLevels = 5;

            let isAnimating = false;

            function hexToRgba(hex, alpha) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }

            function drawChartBackground(attributes, labelDistanceMultiplier) {
                const numAttributes = attributes.length;
                const angleSlice = (Math.PI * 2) / numAttributes;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                for (let i = 1; i <= numLevels; i++) {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, (maxRadius * i) / numLevels, 0, Math.PI * 2);
                    ctx.strokeStyle = 'black';
                    ctx.setLineDash([4, 4]);
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#64748b';
                ctx.font = '10px Inter';
                for (let i = 0; i <= numLevels; i++) {
                    ctx.fillText(i === 0 ? '0' : i.toString(), centerX + 5, centerY - (maxRadius * i) / numLevels - 5);
                }

                for (let i = 0; i < numAttributes; i++) {
                    const angle = i * angleSlice - Math.PI / 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(centerX + maxRadius * Math.cos(angle), centerY + maxRadius * Math.sin(angle));
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }

                ctx.font = 'bold 12px Inter';
                ctx.fillStyle = '#334155';
                for (let i = 0; i < numAttributes; i++) {
                    const angle = i * angleSlice - Math.PI / 2;
                    const labelRadius = maxRadius * labelDistanceMultiplier;
                    const x = centerX + labelRadius * Math.cos(angle);
                    const y = centerY + labelRadius * Math.sin(angle);
                    ctx.textAlign = (angle > -Math.PI / 2 && angle < Math.PI / 2) ? 'left' : (angle > Math.PI / 2 || angle < -Math.PI / 2) ? 'right' : 'center';
                    ctx.fillText(attributes[i], x, y);
                }
            }

            function animateLineDrawing(attributes, data, duration, color, labelDistance) {
                if (isAnimating) return;
                isAnimating = true;

                const numAttributes = attributes.length;
                const angleSlice = (Math.PI * 2) / numAttributes;

                const points = data.map((value, i) => {
                    const radius = (maxRadius * Math.max(0, Math.min(value, 5))) / numLevels;
                    const angle = i * angleSlice - Math.PI / 2;
                    return { x: centerX + radius * Math.cos(angle), y: centerY + radius * Math.sin(angle) };
                });

                let progress = 0;
                let startTime = null;

                function animationStep(timestamp) {
                    if (!startTime) startTime = timestamp;
                    progress = Math.min((timestamp - startTime) / duration, 1);
                    drawChartBackground(attributes, labelDistance);

                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    const currentSegment = progress * points.length;
                    for (let i = 0; i < points.length; i++) {
                        const nextPoint = points[(i + 1) % points.length];
                        if (currentSegment > i) {
                            if (currentSegment < i + 1) {
                                const segmentProgress = currentSegment - i;
                                ctx.lineTo(points[i].x + (nextPoint.x - points[i].x) * segmentProgress, points[i].y + (nextPoint.y - points[i].y) * segmentProgress);
                            } else {
                                ctx.lineTo(nextPoint.x, nextPoint.y);
                            }
                        }
                    }

                    ctx.strokeStyle = color;
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.stroke();

                    if (progress < 1) {
                        requestAnimationFrame(animationStep);
                    } else {
                        fillPolygon(points, color);
                        generateBtn.disabled = false;
                        generateBtn.innerText = "重新生成";
                        isAnimating = false;
                    }
                }

                generateBtn.disabled = true;
                generateBtn.innerText = "生成中...";
                requestAnimationFrame(animationStep);
            }

            function fillPolygon(points, color) {
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                points.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.closePath();
                ctx.fillStyle = hexToRgba(color, 0.2);
                ctx.fill();
            }

            function generateChartFromInputs() {
                let currentAttributes = [];
                let currentData = [];
                for (let i = 0; i < 6; i++) {
                    const attrContainer = document.getElementById(`attr-${i}`);
                    const name = attrContainer.querySelector('input[type="text"]').value || `属性 ${i+1}`;
                    const value = parseFloat(attrContainer.querySelector('input[type="number"]').value) || 0;
                    currentAttributes.push(name);
                    currentData.push(value);
                }

                const displayOrderAttributes = [currentAttributes[5], currentAttributes[0], currentAttributes[1], currentAttributes[2], currentAttributes[3], currentAttributes[4]];
                const displayOrderData = [currentData[5], currentData[0], currentData[1], currentData[2], currentData[3], currentData[4]];

                const duration = 3500 - document.getElementById('speedControl').value;
                const color = document.getElementById('colorControl').value;
                const labelDistance = document.getElementById('labelDistanceControl').value / 100;
                animateLineDrawing(displayOrderAttributes, displayOrderData, duration, color, labelDistance);
            }

            function initialDraw() {
                 let currentAttributes = [];
                 for (let i = 0; i < 6; i++) {
                     const attrContainer = document.getElementById(`attr-${i}`);
                     currentAttributes.push(attrContainer.querySelector('input[type="text"]').value);
                 }
                 const displayOrderAttributes = [currentAttributes[5], currentAttributes[0], currentAttributes[1], currentAttributes[2], currentAttributes[3], currentAttributes[4]];
                 const labelDistance = document.getElementById('labelDistanceControl').value / 100;
                 drawChartBackground(displayOrderAttributes, labelDistance);
            }

            initialDraw();
            generateBtn.addEventListener('click', generateChartFromInputs);
        });
    </script>
</body>
</html>

